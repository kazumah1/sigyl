# Environment Variable Injection for Multi-Tenant MCP Servers

## Problem Statement

Our MCP server deployment was failing because servers expected environment variables (like API keys) to be available at runtime, but we couldn't inject different environment variables for different users on the same Cloud Run instance. This created a multi-tenant conflict where:

- **Static Environment Variables**: We were injecting environment variables at deployment time in Cloud Run
- **Multi-tenant Conflict**: Multiple users accessing the same Cloud Run instance would all get the same environment variables
- **No User Isolation**: User-specific secrets like API keys couldn't be properly isolated

## Solution: Hybrid Gateway Injection

We implemented a **hybrid approach** that injects environment variables dynamically through our gateway proxy system:

### How It Works

1. **Gateway Proxy**: Users connect through our gateway (`/api/v1/gateway/:sessionId/*`)
2. **Dynamic Injection**: Environment variables are injected as headers and request context
3. **Multi-Source Access**: MCP servers can access variables from multiple sources with fallbacks

### Injection Methods

```typescript
// Method 1: Gateway Headers
headers['X-Secret-API_KEY'] = userSecrets.apiKey;
headers['X-Env-API_KEY'] = userSecrets.apiKey;

// Method 2: Request Context (for MCP protocol)
requestBody.context.environment = session.userSecrets;

// Method 3: Fallback to process.env (traditional deployment)
if (noGatewayVariables) {
  environment = process.env;
}
```

## Changes Made

### 1. Gateway Route (`packages/registry-api/src/routes/gateway.ts`)
- **Enhanced proxy logic** to inject environment variables as headers
- **Request context injection** for MCP protocol requests
- **Improved error handling** and response forwarding

### 2. MCP Server Template (`packages/registry-api/examples/mcp-server-template.ts`)
- **Hybrid environment extraction** middleware
- **Multiple fallback strategies** for environment variable access
- **Health check endpoint** to verify injection

### 3. CLI Generator (`packages/cli/ts-cli/src/lib/mcp-generator.ts`)
- **Updated TypeScript/JavaScript server generation** to be gateway-compatible
- **Environment variable injection** in generated tools
- **Backward compatibility** with traditional `process.env` deployment

### 4. Documentation (`packages/registry-api/docs/server-templates.mdx`)
- **Complete server templates** with hybrid approach
- **Compatibility guidelines** for different deployment methods
- **Best practices** for environment variable handling

## Benefits

✅ **Multi-tenant Support**: Each user gets their own environment variables  
✅ **Cost Efficiency**: Multiple users share the same Cloud Run instance  
✅ **Security**: Environment variables not baked into containers  
✅ **Dynamic Updates**: Users can change variables without redeployment  
✅ **Backward Compatibility**: Works with existing servers and traditional deployment  

## Downstream Implications

### 1. **@/ts-cli Generated Servers**
- **All new servers** generated by the CLI are now gateway-compatible
- **Existing servers** continue to work with `process.env` fallback
- **No breaking changes** for current deployments

### 2. **Deployment Process**
- **No changes needed** to Cloud Run deployment (removed static env injection)
- **Gateway handles** all environment variable injection
- **Simplified deployment** configuration

### 3. **User Experience**
- **Seamless integration** - users don't need to change their MCP servers
- **Automatic fallback** - works with both gateway and traditional deployment
- **Health checks** - easy debugging and verification

### 4. **Database Schema**
- **New table**: `gateway_sessions` for temporary session storage
- **Existing tables**: No changes to `mcp_secrets` or other tables
- **Cleanup process**: Automatic expiration of gateway sessions

### 5. **API Endpoints**
- **New endpoint**: `/api/v1/gateway/connect` for creating gateway sessions
- **Proxy endpoint**: `/api/v1/gateway/:sessionId/*` for proxying requests
- **Health endpoint**: `/health` on MCP servers for debugging

## Migration Guide

### For Existing MCP Servers
1. **No immediate action required** - servers continue to work with `process.env`
2. **Optional upgrade** - add the hybrid middleware for gateway compatibility
3. **Health check** - add `/health` endpoint for debugging

### For New MCP Servers
1. **Use the CLI** - `@/ts-cli` now generates gateway-compatible servers
2. **Follow templates** - use the provided server templates
3. **Test locally** - verify with `API_KEY=test node server.js`

### For Frontend Integration
1. **Gateway URLs** - use `/api/v1/gateway/connect` to create sessions
2. **Session management** - gateway sessions expire after 1 hour
3. **Error handling** - handle session expiration gracefully

## Testing

### Local Testing
```bash
# Test with traditional environment variables
API_KEY=your_key node server.js

# Check health endpoint
curl http://localhost:8080/health
```

### Gateway Testing
```bash
# Create gateway session
curl -X POST /api/v1/gateway/connect \
  -H "Content-Type: application/json" \
  -d '{"mcpServerUrl": "https://your-server.com", "userApiKey": "sk_..."}'

# Use gateway URL
curl https://api.sigyl.dev/gateway/{sessionId}/mcp
```

## Future Considerations

1. **Session Management**: Consider longer session times for production
2. **Caching**: Implement caching for frequently accessed environment variables
3. **Monitoring**: Add metrics for gateway usage and session management
4. **Security**: Consider additional encryption for sensitive environment variables

This solution provides a robust, scalable approach to multi-tenant environment variable injection while maintaining backward compatibility and developer experience.